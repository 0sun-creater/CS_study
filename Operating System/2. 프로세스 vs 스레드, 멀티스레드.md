# 프로세스
'실행 중인 프로그램'   
실행 되기 전까지는 보조기억장치에 있는 데이터 덩어리        
메모리에 적재하고 실행하는 순간 프로세스 -> 이 과정을 '프로세스를 생성한다'라고 표현    


윈도우 : 작업 관리자 [프로세스] 탭   
유닉스 : ps 명령어   

### 종류
1. 포그라운드 프로세스 (foreground process)
   사용자가 볼 수 있는 공간에서 실행되는 프로세스
2. 백그라운드 프로세스 (background process)
   보이지 않는 공간에서 실행되는 프로세스
   사용자와 직접 상호작용이 가능할 수도 있음
   - 데몬 (daemon) / 서비스 (service) : 사용자와 상호작용 하지 않고 정해진 일만 수행하는 프로세스


## 프로세스 제어 블록 (PCB : Process Control BLock)
모든 프로세스는 실행을 위해 CPU를 필요로 하지만 CPU 자원은 한정되어 있음           
운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분함          


자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고 시간이 끝났음을 알리는 인터럽트 발생 (타이머 인터럽트)            
타이머 인터럽트 : 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트 = 타임아웃 인터럽트         


- PCB는 프로세스와 관련된 정보를 저장하는 자료 구조
- 커널 영역에 생성됨
- 특정 프로세스를 식별하고 해당 프로세스를 처리하는 데 필요한 정보 판단 가능             
- 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기      

   
### 담기는 정보
1. 프로세스 ID
2. 레지스터 값 : 이전까지 진행했던 작업을 이어서 실행할 수 있음
3. 프로세스 상태
4. CPU 스케줄링 정보
5. 메모리 관리 정보 : 프로세스 주소 
6. 사용한 파일과 입출력장치 목록


## 문맥 교환 (Context Switching)
하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어갈 때 일어나는 일    
문맥 : 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보 = PCB    
< 과정 >
1.  프로세스 A 실행
2.  프로세스 A의 문맥을 PCB에 저장
3.  프로세스 B의 PCB로부터 문맥 가져오기
4.  프로세스 B 실행
5.  프로세스 B의 문맥을 PCB에 저장
6.  프로세스 A의 PCB로부터 문맥 가져오기
7.  ... 반복

위에서 2,3 / 5,6 번에서 문맥 교환이 이뤄지고 있다.           

문맥 교환이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 가며 수행되기 때문에 눈에는 동시에 실행되는 것처럼 보임        
-> 오버헤드가 발생할 수 있기 때문에 자주 일어난다고 반드시 좋은 건 아님         

## 프로세스의 메모리 영역
커널 영역에는 PCB가 생성   
나머지 사용자 영역에는 ?
### 1. 코드영역 (code segment=text segment) - 정적 할당 영역
실행할 수 있는 코드 / 기계어로 이루어진 명령어 저      장   
읽기 전용 공간 (read-only) : 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기는 금지   
### 2. 데이터 영역 (data segment) - 정적 할당 영역
프로그램이 실행되는 동안 유지할 데이터 저장         
**전역 변수** 가 대표적
### 3. 힙 영역 - 동적 할당 영역
프로그래머가 직접 할당할 수 있는 저장 공간             
프로그래밍 과정에서 힙 영역에 메모리 공간을 할당했다면 언젠가는 반환해야함. 그렇지 않다면 메모리 낭비를 초래하고 이런 문제를 "메모리 누수(memory leak)" 라고 함   
일반적으로 메모리의 낮은 주소에서 높은 주소로 할당 됨         
### 4. 스택 영역 - 동적 할당 영역 
데이터를 일시적으로 저장하는 공간         
**매개변수, 지역변수**가 대표적
일시적으로 저장할 데이터는 push되고, 더이상 필요하지 않은 데이터는 pop됨     
일반적으로 높은 주소에서 낮은 주소로 할당 됨     
그래야 힙 영역과 스택 영영에 데이터가 쌓여도 새롭게 할당되는 주소가 겹칠 일이 없기 때문.      

![image](https://github.com/0sun-creater/CS_study/assets/54173210/bdbb176d-b944-4cd3-935a-137848b2456f)

## 프로세스 상태
PCB를 통해 인식하고 관리    

### 1) 생성 상태 (new)
이제 막 메모리에 적재되어 PCB를 할당 받은 상태           

### 2) 준비 상태 (ready)
차례 기다리는 상태              
디스패치(dispatch) : 준비-> 실행

### 3) 실행 상태 (running)
CPU를 할당받아 실행 중인 상태          
-  타이머 인터럽트가 발생하면 다시 준비 상태                   
-  실행 도중 입출력장치를 사용하여 장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태      

### 4) 대기 상태 (blocked)
특정 이벤트가 일어나길 기다릴 때의 상태             
입출력 작업은 CPU에 비해 처리 속도가 느리기에 입출력 완료 인터럽트를 받을 때까지 기다려야 한다.            
입출력장치의 작업이 완료되면 다시 준비 상태          

### 5) 종료 상태 (terminated)
프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함             

![image](https://github.com/0sun-creater/CS_study/assets/54173210/c9799de0-b016-44ad-b691-6328c2d70eb9)

## 프로세스 계층 구조
프로세스가 프로세스를 낳는 계층적인 구조로 프로세스 관리함 (트리구조)             
프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다.       
1. 부모 프로세스 : 생성한 프로세스
2. 자식 프로세스 : 부모 프로세스에 의해 생성된 프로세스

- 부모와 자식은 다른 프로세스임 : 다른 PID를 가짐
- 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID가 기록되어 있음 (PPID)
- 


----
----
# 스레드
